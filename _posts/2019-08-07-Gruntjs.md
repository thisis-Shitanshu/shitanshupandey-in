---
layout: post
title:  "Grunt"
categories: Grunt
---

- Installing grunt-cli does not install the Grunt task runner! The job of the Grunt CLI is simple: run the version of Grunt which has been installed next to a Gruntfile.
    - *This allows multiple versions of Grunt to be installed on the same machine simultaneously.*
- Each time grunt is run, it looks for a locally installed Grunt using node's require() system.
    - If a locally installed Grunt is found, the CLI loads the local installation of the Grunt library, applies the configuration from your Gruntfile, and executes any tasks you've requested for it to run.


# Preparing a new Grunt project
- A typical setup will involve adding two files to your project: package.json next to the Gruntfile.

## Installing Grunt and gruntplugins
- Start with the example below, and expand as needed
```json
    {
        "name": "my-project-name",
        "version": "0.1.0",
        "devDependencies": {
            "grunt": "~0.4.5",
            "grunt-contrib-jshint": "~0.10.0",
            "grunt-contrib-nodeunit": "~0.4.1",
            "grunt-contrib-uglify": "~0.5.0"
        }
    }
```
## The Gruntfile
- A Gruntfile is  comprised of the following parts:
    - The "wrapper" function
    - Project and task configuration
    - Loading Grunt plugins and tasks
    - Custom tasks

- Following Gruntfile:
    - Project metadata is imported into the Grunt config from the project's package.json file
    - and the grunt-contrib-uglify plugin's uglify task is configured to minify a source file 
        - and generate a banner comment dynamically using that metadata.
```javascript
    module.exports = function(grunt) {
        // Project configuration.
        
        grunt.initConfig({            
            pkg: grunt.file.readJSON('package.json'),
            uglify: {
                options: {
                    banner: '/* <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> */\n'
                },
                build: {
                    src: 'src/<%= pkg.name %>.js',
                    dest: 'build/<%= pkg.name %>.min.js'
                }
            }
        });

        // Load the plugin that provides the "uglify" task.
        grunt.loadNpmTasks('grunt-contrib-uglify');

        // Default tasks(s).
        grunt.registerTasks('default', ['uglify'])
    } 
```

## Gruntfile Components
- The "wrapper" function: all of your Grunt code must be specified inside this function.
- Most Grunt tasks rely on configuration data defined in an object passed to the grunt.initConfig method.
    - Configuration data like filepaths and file lists may be specified this way to reduce repetition.
    - Since this is JS, one can even programmatically generate the configuration if necessary.
    - **Most tasks expects its configuration to be specified in a property of the same name.** 
- Many commonly used tasks like concatenation, minification and linting are available as grunt plugins.
    - As long as a plugin is specified in package.json as a dependency, 
    - and has been installed via npm install, it may be enabled inside your Gruntfile with a simple command.
- You can configure Grunt to run one or more tasks by default by defining a default task.
    - Any number of tasks (with or without arguments) may be specified in the array.

## Custom tasks
- If your project requires tasks not provided by a Grunt plugin, you may define custom tasks right inside the Gruntfile.
    - Custom project-specific tasks don't need to be defined in the Gruntfile; 
        - they may be defined in external .js files 
        - and loaded via the grunt.loadTasks method.
```javascript
    module.exports = function(grunt) {
        // A very basic default tasks.
        grunt.registerTask('default', 'Log some stuff.', function() {
            grunt.log.write('Loggging some stuff...').ok();
        });

    }
```


# Configuring tasks
- Task configuration is specified in your Gruntfile via the `grunt.initConfig` method.
- When a task is run, Grunt looks for its configuration under a property of the same name.
    - Multi-tasks can have multiple configurations, defined using arbitrarily named "targets."
        - Specifying both a task and target like `grunt concat:foo` or `grunt concat:bar` will process just the specified target's configuration, 
        - while running `grunt concat` will iterate over all targets, processing each in turn.
- Inside a task configuration, an `options` property may be specified to override built-in defaults.
    - Target-level options will override task-level options.
```javascript
    module.exports = function(grunt) {
        grunt.initConfig({
            concat: {
                options: {
                        // Task-level options may go here, overriding task defaults.
                    },
                foo: {
                    options: {
                        // "foo" target options may go here, overriding task-level options.
                    }
                },
                bar: {
                    // No options specified; this target will use task-level options.
                }
            },
            uglify: {
                bar: {
                    // uglify task "bar" target options and files go here.
                }
            },
            // Arbirary non-task-specific properties.
            my_property: 'whatever',
            my_src_files: ['foo/*.js', 'bar/*.js']
        });
    }
```

## Working with Files
- Because most tasks perform file operations, Grunt has powerful abstractions for declaring on which files the task should operate.
- All file formats support src and dest but the `Compact` and `Files Array` formats support a few additional properties:
    - `Compact` allows a single src-dest (source-destination) file mapping per-target.
    - `Files Array` supports multiple src-dest mappings per-target, where the property name is the destination file, and its value is the source file(s). 
        - While also allowing additional properties per mapping.
```javascript
    // Compact format
    module.export = function(grunt) {
        grunt.initConfig({
            jshint: {
                foo: {
                    src: [
                        'src/aa.js', 
                        'src/aaa.js'
                    ]
                }
            },
            concat: {
                bar: {
                    src: ['src/bb.js', 'src/bbb.js'],
                    dest: 'dest/b.js',
                }
            }
        });
    }

    // Files Object format
    module.export = function(grunt) {
        grunt.initConfig({
            concat: {
                foo: {
                    files: {
                        'dest/a.js': ['src/aa.js', 'src/aaa.js'],
                        'dest/a1.js': ['src/aa1.js', 'src/aaa1.js']
                    }
                },
                bar: {
                    files: {
                        'dest/b.js': ['src/bb.js', 'src/bbb.js'],
                        'dest/b1.js': ['src/bb1.js', 'src/bbb1.js'],
                    }
                }
            }
        });
    }

    // File Array format
    module.export = function(grunt) {
        grunt.initConfig({
            concat: {
                foo: {
                    files: [
                        {
                            src: ['src/aa.js', 'src/aaa.js'],
                            dest: 'dest/a.js'
                        },
                        {
                            src: ['src/aa1.js', 'src/aaa1.js'],
                            dest: 'dest/a1.js'
                        }
                    ]
                },
                bar: {
                    files: [
                        {
                            src: ['src/bb.js', 'src/bbb.js'],
                            dest: 'dest/b/',
                            nonull: true
                        },
                        {
                            src: ['src/bb1.js', 'src/bbb1.js'],
                            dest: 'dest/b1/',
                            filter: 'isFile'
                        }
                    ]
                }
            }
        });
    };
```

## Custom Filter Function
- `filter` Enter a vaild [fs.Stats method name](https://nodejs.org/docs/latest/api/fs.html#fs_class_fs_stats) or a function that is passed the matched src filepath and returns true or false.
```javascript
    // Clear a folder that's empty.
    grunt.initConfig({
        clean: {
            foo: {
                src: ['tmp/**/*'],
                filter: function(filepath) {
                    return (grunt.file.isDir(filepath) && require('fs').readdirSync(filepath).length === 0)
                }
            }
        }
    });
```
- Filter using globbing and expand: true
```javascript
    grunt.initConfig({
        copr: {
            templates: {
                files: [{
                    expand: true,
                    // Parent folder of original CSS templates
                    cwd: ['templates/css'],
                    // Collect all `*.css` files within the parent folder.
                    src: '**/*.css',
                    // Stores the collected `*.css` files in your `src/css` folder
                    dest: 'src/css/',
                    // `dest`, in the instance, is the filepath of each matched `src`
                    filter: function(dest) {
                        var cwd = this.cwd;
                        src = dest.replace(new RegExp('^', + cwd), '');
                        dest = grunt.task.current.data.files[0].dest;
                        // Copies `src` files ONLY if their destionations are unoccupied
                        return (!grunt.file.exists(dest + src));
                    }
                }]
            }
        }
    });
```

### Globbing patterns
- `*` macthed any number of characters, but not `/` (subdirectories): `foo/*.js`.
- `?` matches a single character, but not `/`.
- `**` matches any number of characters, including `/`, as long as it's the only thing in a path part: `foo/**/*.js`.
- `{}` allows for a comma-separated list of "or" expressions.
- `!` at the beginning of a pattern will negate the match.

- Grunt allows arrays of file paths or globbing patterns to be specified.
    - Patterns are processed in-order, with !-prefixed matches excluding matched files from the result set.

```javascript
// Using Globbing

// You can specify single files:
{src: 'foo/this.js', dest: ...}
// Or you can generalize with a glob pattern:
{src: 'foo/th*.js', dest: ...}

// This single node-glob pattern:
{src: 'foo/{a,b}*.js', dest: ...}
// Could also be written like this:
{src: ['foo/a*.js', 'foo/b*.js'], dest: ...}

// All .js files, in foo/, in alpha order:
{src: ['foo/*.js'], dest: ...}
// Here, bar.js is first, followed by the remaining files, in alpha order:
{src: ['foo/bar.js', 'foo/*.js'], dest: ...}

// All files except for bar.js, in alpha order:
{src: ['foo/*.js', '!foo/bar.js'], dest: ...}
// All files in alpha order, but with bar.js at the end.
{src: ['foo/*.js', '!foo/bar.js', 'foo/bar.js'], dest: ...}

// Templates may be used in filepaths or glob patterns:
{ src: ['src/<%= basename =>'], dest: 'build/<%= basename %>.min.js' }
// But they may also reference file lists defined elsewhere in the config:
{src: ['foo/*.js', '<%= jshint.all.src %>'], dest: ...}
```

### Building the files objct dynamically
When you want to process many individual files, a few additional properties may be used to build a files list dynamically.
`expand` Set to true will enable the following properties:
    - cwd, src, dest, ext, extDot, flattern, rename

*Performing `uglify` dynamic mapping.*
```javascript
    grunt.initConfig({
        uglify: {
            dynamic_mappings: {
                // Grunt will search for "**/*.js" under "lib/" when the "uglify" task
                // runs and build the appropriate src-dest file mappings then, so you
                // don't need to update the Gruntfile when files are added or removed.
                files: [
                    {
                        expand: true,     // Enable dynamic expansion.
                        cwd: 'lib/',      // Src matches are relative to this path.
                        src: ['**/*.js'], // Actual pattern(s) to match.
                        dest: 'build/',   // Destination path prefix.
                        ext: '.min.js',   // Dest filepaths will have this extension.
                        extDot: 'first'   // Extensions in filenames begin after the first dot
                    },
                ],
            },
        },
    });
```

## rename Function
- In the following example, files are copied from the dev folder to the dist folder, and renamed to have the word "beta" removed.
```javascript
    grunt.initConfig({
        copy: {
            production: {
                files: [{
                    expand: true,
                    cwd: 'dev/',
                    src: ['*'],
                    dest: 'dist/',
                    rename: function (dest, src) {          // The `dest` and `src` values can be passed into the function
                        return dest + src.replace('beta',''); // The `src` is being renamed; the `dest` remains the same
                    }
                }]
            }
        }
    });
```

## Templates
- Templates specified using `<% %>` delimiters will be automatically expanded when tasks read them from the config. 
    - Templates are expanded recursively until no more remain.
    - Additionally, `grunt` and its methods are available inside templates, eg. `<%= grunt.template.today('yyyy-mm-dd') %>`.

## Importing External Data
Grunt has `grunt.file.readJSON` and `grunt.file.readYAML` methods for importing JSON and YAML data.
```javascript
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),
        uglify: {
            options: {
                banner: '/*! <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> */\n'
            },
            dist: {
                src: 'src/<%= pkg.name %>.js',
                dest: 'dist/<%= pkg.name %>.min.js'
            }
        }
    });
```


# Sample Gruntfile
```javascript
    module.exports = function(grunt) {
        grunt.initCOnfig({
            pkg: grunt.file.readJSON('package.json'),
            concat: {
                options: {
                    // define a string to put between each file in the concatenated output
                    separator: ';'
                },
                dist: {
                    // the files to concatenate
                    src: ['src/**/*.js'],
                    // the location of the resulting JS file
                    dest: 'dist/<%= pk.name %>.js'
                }
            },
            uglify: {
                options: {
                    // the banner is inserted at the top of the output.
                    banner: '/*! <%= pkg.name %> <%= grunt.template.today("dd-mm-yyyy") %> */\n'
                },
                dist: {
                    files: {
                        'dist/<%= pkg.name %>.min.js': ['<%= concat.dist.dest %>']
                    }
                }
            },
            qunit: {
                files: ['test/**/*.html']
            },
            jshint: {
                // define the files to lint
                files: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
                options: {
                    // more options here if you want to override JSHint defaults
                    globals: {
                        jQuery: true,
                        console: true,
                        module: true
                    }
                }
            },
            // `grunt-contrib-watch` runs the tasks you specify, in the order they appear. This can be run on the command line with grunt watch.
            watch: {
                files: ['<%= jshint.files %>'],
                tasks: ['jshit', 'qunit']
            }
        });

        // Load in the Grunt plugins previously installed through npm.
        grunt.loadNpmTasks('grunt-contrib-uglify');
        grunt.loadNpmTasks('grunt-contrib-jshint');
        grunt.loadNpmTasks('grunt-contrib-qunit');
        grunt.loadNpmTasks('grunt-contrib-watch');
        grunt.loadNpmTasks('grunt-contrib-concat');

        // Set up tasks
        // this would be run by typing "grunt test" on the command line
        grunt.registerTask('test', ['jshit', 'qunit']);

        // the default task can be run just typing "grunt" on the command line
        grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);
    };
```


## Creating Tasks
- Alias Tasks: Whenever this "alias task" is run, every specified tasks in taskList will be run, in the order specified. *With or without task arguments.*
```javascript
    grunt.registerTask('dist', ['concat', 'uglify:dist']);
```

- Multi Tasks: Specifying both a task and target like `grunt concat:foo` or `grunt concat:bar` will process just the specified target's configuration.
    - `grunt concat` will iterate over all targets, processing each in turn.
    - *If a task has been renamed with grunt.task.renameTask, Grunt will look for a property with the new task name in the config object.*

- "Basic" Tasks: When a basic task is run, Grunt doesn't look at the configuration or environmentâ€”it just runs the specified task function, passing any specified colon-separated arguments in as function arguments.
```javascript
    grunt.registerTask('foo', 'A sample task that logs stuff.', function(arg1, arg2) {
        if(arguments.length === 0) {
            grunt.log.writeln(this.name + ", no args");
        } else {
            grunt.log.writeln(this.name + ", " + arg1 + " " + arg2);
        }
    });
```

## Custome tasks:
```javascript
    // Inside a task, you can run other task.
    grunt.registerTask('foo', 'My "foo" tasks.', function() {
        // Enqueue "bar" and "baz" tasks, to run after "foo" finishes, in-order.
        grunt.task.run('bar', 'baz');
        // Or:
        grunt.task.run(['bar', 'baz']);
    })

    // Tasks can be asynchronous
    grunt.registerTask('asyncfoo', 'My "asyncfoo" task.', function() {
        // Force task into async mode and grab a handle to the "done" function.
        var done = this.async();
        // Run some sync stuff.
        grunt.log.writeln('Processing task...');
        // Add some async stuff.
        setTimeout(function() {
            grunt.log.writenln('All done!');
            done();
        }, 1000);
    });

    grunt.registerTask('foo', 'My "foo" task.', function(a, b) {
        grunt.log.writenln(this.name, a, b);
    });

    // Usage:
    // grunt foo
    //   logs: "foo", undefined, undefined
    // grunt foo:bar
    //   logs: "foo", "bar", undefined
    // grunt foo:bar:baz
    //   logs: "foo", "bar", "baz"

    // Tasks can fail if any errors were logged.
    grunt.registerTask('foo', 'My "foo" task.', function() {
        if(failureOfSomeKind) {
            grunt.log.error('This is an error message.');
        }

        // Fail by returning false if the task had errors
        if(ifErrors) { return false; }

        grunt.log.writeln('This is the success message');
    });

    // When tasks fail, all subsequent tasks will be aborted nless `--force` was specified.

    // Tasks can be dependent on the successful execution of other tasks.
    // `grunt.task.requires` won't actually run the other task(s). It'll just check to see that it has run and not failed.
    grunt.registerTask('foo', 'My "foo" task.', function() {
        return false;
    });

    grunt.registerTask('bar', 'My "bar" task.', function() {
        // Fail task if "foo" task failed or never ran.
        grunt.task.requires('foo');
        // The code executes if the "foo" task ran successfully.
        grunt.log.writeln('Hello, world.');
    });
    
    // Tasks can fail if required configuration properties don't exist.
    grunt.registerTask('foo', 'My "foo" task.', function() {
        // Fail task if "meta.name" config prop is missing.
        // Format 1: String
        grunt.config.requires('meta.name');
        // or Format 2: Array
        grunt.config.requires(['meta', 'name']);
        // Log... conditionally.
        grunt.log.writenln('This will only log if meta.name is defined in the config.');
    });

    //Tasks can access configuration properties.
    grunt.registerTask('foo', 'My "foo" task.', function() {
        // Log the property value. Return null if the property is undefined.
        grunt.log.writeln('The meta.name property is: ' + grunt.config('meta.name'));

        // Also logs the property value. Returns null if the property is undefined.
        grunt.log.writeln('The meta.name is property is: ' + grunt.config(['meta', 'name']));
    });
```


# Grunt: TypeScript
- Grunt-ts is an npm package that handles TypeScript compilation work in GruntJS build scripts.

## Quickstart
```
    $ npm install typescript --save-dev
    $ npm install grunt --save-dev
    $ npm install grunt-cli -g
```

## Getting Started
- Install `grunt-ts`.
```
    $ npm install grunt-ts
```
- Add the `ts` task in your `Gruntfile.js`
```javascript
    // Gruntfile.js will compile your TypeScript project using the specified tsconfig.json file.
    
    module.exports = function(grunt) {
        grunt.initConfig({
            ts: {
                default: {
                    tsconfig: './tsconfig.json'
                }
            }
        });
        grunt.loadNpmTasks("grunt-ts");
        grunt.registerTask("default", ["ts"]);
    };
```
- Run `grunt` in CLI in root dir to compile TypeScript code.


### Delete Task
```
    $ npm install grunt-contrib-clean --save-dev
```
- Include `grunt.loadNpmTasks('grunt-contrib-clean');` in `Gruntfile`.
- In `Gruntfile`:
```javascript
    // Deletes all .js files, but skips min.js files
    clean: {
        js: [
            'path/to/dir/*.js', 
            '!path/to/dir/*.min.js'
        ]
    }
```

### Copy Task
```
    $ npm install grunt-contrib-copy --save-dev
```
- Inside Gruntfile: `grunt.loadNpmTasks('grunt-contrib-copy');`

- The task:
```javascript

```