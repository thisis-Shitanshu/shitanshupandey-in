---
layout: post
title: "React.js V: Performance"
categories: React.js Performance
published: true
---

Notes on amplifying performance in React Applications.

*"Do not optimize your code ahead of time. Only write optimize code once there's a problem. Because everything has a cost."*

# #Chuncks
- React gives code-splitting and chucking, right at the gate.
- By default, when in production all the js is downloaded by the browser for the pages even if the user has not visited the page.

# #React Lazy + Suspense
- Webpack helps us bundle all of our files.
    - By default Webpack uses Static Imports.
    - To increade performance, use Dynamic Syntax.
        - Where `imports` are pulled in like a promise. Only import file and load it when necessary.

- Implemented using `lazy` from `react` library.
    - Wrap the components inside the `lazy` function.

    ```js
    const HomePage = lazy(() => import('./pages/homepage/homepage.component'));
    ```

    - React Router by default allows us to support code-splitting.
        - Webpack ahead of time, will already have chuncked our code using lazy loading function.
        - When user goes through different routes, those chuncks are downloaded accordingly.

    - Using `Suspense` Component from `react` we can pass `Route` component as children component to later run async code to load the lazy function.

    ```js
    <Suspense fallback={<div>...Loading</div>}>
        <Route exact path='/' component={HomePage} />
    </Suspense>
    ```

# #Error Boundaries using `lazy` loading
- When lazy loading, due to Network Error there may be a possibilty that the application fails to fetch new chunk of js files.
    - In that case the Spinner (fallback will load indefinetly).
    - Or if an error comes back `Suspense` does not know what to do with it, and the app will break.
- Solution to deal with this is to use an Error Boundary.
- Introduced in React 16.6, Error Boundary is a way to write an unique component, very similar to suspense catch an error and render a fallback component or UI instread of that error to occur.

## #Writing an Error Boundary Code
- React Identify an Error Boundary code when building an component with following life cycle method:
    - `componentDidCatch`
    - `static getDerivedStateFromError`

    ```js
    import React, { Component } from 'react';

    class ErrorBoundary extends Component {
        constructor() {
            super();

            this.state = {
                hasErrored: false
            }
        }

        static getDerivedStateFromError(error) {
            // Catches error from any of the children of this Error Boundary Component.
            return { hasErrored: true }
        }

        componentDidCatch(error, info) {
            console.log(error);
        }

        render() {
            if(this.state.hasErrored) {
                return <div> Something went wrong </div>
            }

            return this.props.children;
        }
    }

    export default ErrorBoundary;
    ```

# #`React.memo`, PureComponent, shouldComponentUpdate
- Component Level Optimization.

## #`shouldComponentUpdate`
- Deciding a component to rerender based on boolean return from this function.

```js
shouldComponentUpdate(nextProps, nextState) {
    return nextProps.text !== this.props.text;
}
```

## #Alternative
- Functional Component:
    - Functional Component always rerenders whenever parent componet rerenders. Its being called an invoked every time.

    ```js
    import React from 'react';

    const Person = ({ person }) => {
        console.log('rendering');
        return (
            <div>
                <p>{person.name}</p>
                <p>{person.age}</p>
            </div>
        );
    };

    export default Person;
    ```

- Using `React.memo`:
    - It's a way to memoise the component, so the component does not rerender if the props value do not change.
    - It implements a shallow comparision like `shouldComponentUpdate` for Class components.
    - This can be done with a class component using: `class Person extends React.PureComponent`.
    - We wrap the Component with `React.memo`

    ```js
    import React from 'react';

    const Person = ({ person }) => {
        console.log('rendering');
        return (
            <div>
                <p>{person.name}</p>
                <p>{person.age}</p>
            </div>
        );
    };

    export default React.memo(Person);
    ```

- Using `React.memo` reduce the speed of initial render.
    - Because initial memoization takes longer than simply passing the component itself.
    - Don't memoize component which do not have state, or props that do not change.

- `React.memo` does **NOT** save us from referential equality.
    - Intentiating the prop value on every render in parent component: `<Person person={{ name: 'jack', age: 22 }} />`
    - Function and Array are also Objects so if you inline function or array on a Component, memoization won't work.

- `reselect` library optimise code similar to using `React.memo`.

# #Optimization Hooks
## #`useCallback`
- When you pass an inline function to a component, you're always instantiating a new function. Which gets around memoized component.
- To memoize a function and not rerender them unnecessarily, use `useCallback`.
    - It memoize a version of the function we wrap in it, and use that same function if it already exists.

    ```js
    const function = new Set();

    const App = () => {
        // ...
        const incrementCount = useCallback(() => setCount(count + 1), [count]);
        
        function.add(incrementCount);

        console.log(functions);
        // ...
    }
    ```

## #`useMemo`
- It is similar to `useCallback`, with exception to that it is only used to cache the value function that does something complex.
    - It memoize the output of the function.
    - Only rerenders when the dependency has changed, until then use the memoized value.

    ```js
    const doSomethingComplicated = useMemo(() => {
        console.log('Computing');
        return ((count * 1000) % 12.4) * 51000 - 4000;
    }, [count]);
    ```

# #Gzipping and Compression
- After optimization by default the react build, react chuncks the js code into multiple gzip files.
- It uses gzip, which is used by backend server to compress file so that while passing files with https to the client, it's in a smaller package where it gets unzipped on the browser.
- By default in some services, you will find the size of these files to be bigger.
    - Heroku: It doesnot offer gzipping, by default.
    - **You need to manually gzip on the Express Server.**
    - Use library for express: `yarn add compression`
        - It precompress the chuncks before sending it to the client.
    - Implement in server: `app.use(compression());`