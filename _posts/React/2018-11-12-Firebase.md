---
layout: post
title: "Firebase"
categories: Firebase
published: true
---

Authentication and Storage with Firebase

# #Introduction
- Create a Firebase Project on Firebase Project.
    - Register app for web.
    - Add Firebase SDK:
        - Copy `firebaseConfig`.
- Add firebase utility library:
    - `yarn add firebase`
    - Config firebase utils to setup sign-in.

    ```js
    import firebase from 'firebase/app';
    import 'firebase/firestore';
    import 'firebase/auth';

    const config = {
        // ... firebase Config
    };

    firebase.initializeApp(config);

    export const auth = firebase.auth();
    export const firestore = firebase.firestore();

    // Google Authentication Utils for Sign in with Pop Up
    const provider = new firebase.auth.GoogleAuthProvider();
    provider.setCustomParameters({ prompt: 'select_account' });
    export const signInWithGoogle = () => auth.signInWithPopup(provider);

    export default firebase;
    ```

- **Set up sign-in method from options avaiable**
- Setting up app to get user data in app state.
    - firebase authentication is an open subscription.
    - It give user authenticated session persistance by default.

    ```js
    // App listening to authentication state change.
    unsubscribeFromAuth = null;
  
    componentDidMount() {
        this.unsubscribeFromAuth = auth.onAuthStateChanged(user => {
        this.setState({
            currentUser: user
        });

        console.log(user);
        })
    }

    componentWillUnmount() {
        this.unsubscribeFromAuth();
    }
    ```

## #Firestore DB
- Create DB
    - Add Collection
        - Add Document
            - Collections...
                - Document...

- Read: Quering Database

```js
import firebase from 'firebase/app';
import 'firebase/firestore';

const firestore = firebase.firestore();

// #1
firestore.collection('users').doc('id').collection('cartItems').doc('id');

// #2
firestore.doc('/users/id/cartItems/id');
firestore.collection('/users/id/cartItems');
```

- Firestore gives back two potential objects:
    - QueryReference (references) and QuerySnapshot (snapshots):
        - Even if nothing exists.
        - They can either be Document or Collection versions.

- We can only make one `.set()` call at a time.
    - To set large amount data, we need to perform a **Batch Write**.
        - a way to group all our calls together into one big request.

```js
export const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {
    const collectionRef = firestore.collection(collectionKey);
    console.log(collectionRef);

    const batch = firestore.batch();
    objectsToAdd.forEach(obj => {
        const newDocRef = collectionRef.doc();
        batch.set(newDocRef, obj);
    });

    return await batch.commit();
};
```

### #QueryReference:
- An object that represents the "current" place in the database.
- Syntax:
    - `firestore.doc('/users/:userId');`
    - `firestore.collections('/users');`
- The object does not have the actual data of the collection or document.
    - It has the **properties** that tell us details about it.
    - or, the method to get the Snapshot object which gives us the data we are looking for.
- It is used for SAVING or GET DATA from perticular data.
- **DocumentReference vs CollectionReference**
    - documentRef objects perform CRUD methods and returns documentSnapshot:
        - .set()
        - .get()
            - Returns Snapshot Object
            - Used to determine data in the current reference.
        - .update()
        - .delete()
        - .onSnapshot()
            - Listener to change in snapshot of the document reference.
            - Returns snapShot on change.
    - collectionRef returns querySnapshot:
        - .add()
        - .get()

### #DocumentSnapshot
It's the object we always get on calling `get` on documentReference object.
- It allows us to check if document exits at this query using the `.exists` property.
- We can also get actual properties on the object by calling the `.data()` method, which returns us a JSON object of the document.

```js
const userRef = firestore.doc(`users/${userAuth.uid}`);
const snapShot = await userRef.get();
console.log(snapShot.data());
```

### #QuerySnapshot / CollectionSnapshot
It's the object we always get on calling `get` on collectionReference object.
- Check for availabilty of any document in the collection:
    - `.empty()`: Returns boolean.
    - `.doc()`: Get an ARRAY of documents in the collection.
    - `.size()`: Number of documents in the collection.

```js
const collectionRef = firestore.collections(`users`);
const collectionSnapShot = await collectionRef.get();
console.log({ collection: collectionSnapShot.docs.map(doc => doc.data()) });
```

# #Observable Pattern: Studying Firebase Subscriptions
- For a stream of events in a timeline, where events accors in asyncronous fashion:
    - Observable is a piece of code that wraps around the stream, so that we can perform actions with the piece of data at each event.
- Observer is a piece of code with three functions on it:
    - next: When new events happens.
        - `next: (nextValue) => { // Do something with value. }`
    - error: When error occurs.
        - `error: (error) => { // Do something with error. }`
    - complete: optional call when stream is finished.
        - `complete: () => { // Do something when finished. }`
- Subscription is a way to tie our observer to event stream using listner.

```js
// Observer passed to Observable.
// Instantiate listener to event of user Authentication Status.
auth.onAuthStateChanged(async userAuth => {
    // ...
}, error => console.log(error));
```
- Observable can have n-number of listener with different function call associated with it.

## ##Promise based data fetch:

```js
fetch('https://firestore.googleapis.com/v1/projects/YOUR_PROJECT_ID/databases/(default)/documents/collections')
.then(response => response.json())
.then(collections => console.log(collections));
```