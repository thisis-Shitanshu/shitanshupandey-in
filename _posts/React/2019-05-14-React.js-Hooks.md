---
layout: post
title: "React.js V: Hooks & Context API"
categories: React.js Hooks ContextAPI
published: true
---
Notes on React Hooks and Context API
Click [here](https://github.com/thisis-Shitanshu/crwn-clothing-ecommerce-react-firebase-stripe/tree/W/ContextAPI) to go to Context API project. 

# #React Hooks
- Pure function with Hooks. E.g., state hook, effect hook.
- Higher than 16.8.
- Can't call hooks under condition or wrap by one, must always be on the top level of the component.
    - Put condition inside the Hook definition.

## #`useState`:
- Functional Component with access to state features.
- Returns Array with Two Values.
    - State Value
    - Set State Function

```js
const [ name, setName ] = useState('INITIAL_VALUE');
```
- It can be used multiple times to create state values in the function.

## #`useEffect`:
- Fire Side-Effects inside functional components.
    - Change State Inside.
- It gets a function, which gets a call when component changes/update/re-renders.
- Pass an array as second parameters.
    - These are the proprties, that the perticular effect has access to.
    - So it will rerender only when those property changes.
- When you pass an empty array, `useEffect` will only run when component mounts.

```js
useEffect(() => {
    console.log('Hello');
}, [values_effect_depends_on]);
```
- To use async function inside `useEffect`, call an `async` function inside.

```js
useEffect(() => {
    const fetchFunc = async () => {
        const response = await fetch(`API?query=${QueryValue}`);
        const resJson = await response.json();
        setUser(resJson[0])
    }

    fetchFunc();
}, [QueryValue]);
```

- `useEffect()` have a clean up function:

```js
useEffect(() => {

    return () => {
        // ...component unmounts
    }
})
```

# #Custom Hooks
- Reusable Effect

```js
// useFetch(): effects/use-fetch.effect.js
import { useState, useEffect } from 'react';

const useFetch = (url) => {
    const [data, setData] = useState(null);

    useEffect(() => {
        const fetchData = async () => {
            const res = await fetch(url);
            const dataArray = await res.json;
            setData(dataArray[0]);
        }

        fetchData();
    });

    return data;
}

export default useFetch();
```

## #`useReducer`:
- It lets us build reducer functions and leverage them as state management inside our components the same way `useState` does.
    - Except, it follows the flow of firing actions and then those action changing a reducer object. Like Redux, but localized to a component.

```js
const INITIAL_STATE = {
    user: null,
    searchQuery: 'Bert'
}

const reducer = (state, action) => {
    switch (action.type) {
        case 'SET_USER':
            return {
                ...state,
                user: action.payload
            }
        case 'SET_SEARCH_QUERY':
            return {
                ...state,
                searchQuery: action.payload
            }
        default:
            return state;
    }
}

const setUser = user => ({
    type: 'SET_USER',
    payload: user
});

const setQuery = queryString => ({
    type: 'SET_SEARCH_QUERY',
    payload: queryString
});

/*
.
.
.
*/

const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
const { user, searchQuery } = state;

dispatch(setUser(USER_DATA));
dispatch(setQuery(SEARCH_QUERY));
```

# #Context API
- Redux library uses the Context API in the background.
- It's a way to store different state and modify those states inside of seperate object, which we would then be able to hook into the components at any level.
    - *Eliminates with Prop-drilling issue.*

- Trade off:
    - Loose Sagas.
    - Loose Thunks.
        - Loose Handle Async action inside out middleware.
    - Recomposablity by using connect to use selector into multiple places.
        - In context you tightly couple component with specific context that it needs.

- Redux is better for large application.

- Context are the blueprint to pass the state & function of a component to any of its nested children through Provider.

- Defining

```js
import { createContext } from 'react';

import SHOP_DATA from './shop.data';

const CollectionsContext = createContext(SHOP_DATA);

export default CollectionsContext;
```

- Consuming using Component Method:

```js
import React from 'react';

import CollectionItem from '../../components/collection-item/collection-item.component';


import CollectionsContext from '../../contexts/collections/collections.context';

import './collection.styles.scss';

const CollectionPage = ({ match }) => {
  return (
    <CollectionsContext.Consumer>
      {
        collections => {
          const collection = collections[match.params.collectionId];
          const { title, items } = collection;
          
          return (
            <div className='collection-page'>
            <h2 className='title'>{title}</h2>
            <div className='items'>
              {items.map(item => (
                <CollectionItem key={item.id} item={item} />
              ))}
            </div>
          </div>
          )
        }
      }
    </CollectionsContext.Consumer>
  );
};


export default CollectionPage;
```

- Using `useContext`

```js
import React, { useContext } from 'react';

import CollectionItem from '../../components/collection-item/collection-item.component';

import CollectionsContext from '../../contexts/collections/collections.context';

import './collection.styles.scss';

const CollectionPage = ({ match }) => {
  const collections = useContext(CollectionsContext);
  const collection = collections[match.params.collectionId];
  const { title, items } = collection;

  return (
    <div className='collection-page'>
      <h2 className='title'>{title}</h2>
      <div className='items'>
        {items.map(item => (
          <CollectionItem key={item.id} item={item} />
        ))}
      </div>
    </div>
  );
};

export default CollectionPage;
```

## #Dynamically Updating the Context
- Defining the Context

```js
import { createContext } from 'react';

const CurrentUserContext = createContext(undefined);

export default CurrentUserContext;
```

- Decalre Provider

```js
<CurrentUserContext.Provider 
    value={this.state.currentUser}
>
    <Header />
</CurrentUserContext.Provider>
```

- Consuming Context

```js
const currentUser = useContext(CurrentUserContext);
```