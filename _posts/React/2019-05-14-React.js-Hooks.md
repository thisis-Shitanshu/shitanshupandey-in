---
layout: post
title: "React.js III: Hooks & Context API"
categories: React.js Hooks ContextAPI
published: true
---
Notes on React Hooks and Context API

# #React Hooks
- Pure function with Hooks. E.g., state hook, effect hook.
- Higher than 16.8.
- Can't call hooks under condition or wrap by one, must always be on the top level of the component.
    - Put condition inside the Hook definition.

## #`useState`:
- Functional Component with access to state features.
- Returns Array with Two Values.
    - State Value
    - Set State Function

```js
const [ name, setName ] = useState('INITIAL_VALUE');
```
- It can be used multiple times to create state values in the function.

## #`useEffect`:
- Fire Side-Effects inside functional components.
    - Change State Inside.
- It gets a function, which gets a call when component changes/update/re-renders.
- Pass an array as second parameters.
    - These are the proprties, that the perticular effect has access to.
    - So it will rerender only when those property changes.
- When you pass an empty array, `useEffect` will only run when component mounts.

```js
useEffect(() => {
    console.log('Hello');
}, [values_effect_depends_on]);
```
- To use async function inside `useEffect`, call an `async` function inside.

```js
useEffect(() => {
    const fetchFunc = async () => {
        const response = await fetch(`API?query=${QueryValue}`);
        const resJson = await response.json();
        setUser(resJson[0])
    }

    fetchFunc();
}, [QueryValue]);
```

- `useEffect()` have a clean up function:

```js
useEffect(() => {

    return () => {
        // ...component unmounts
    }
})
```

# #Custom Hooks
- Reusable Effect

```js
// useFetch(): effects/use-fetch.effect.js
import { useState, useEffect } from 'react';

const useFetch = (url) => {
    const [data, setData] = useState(null);

    useEffect(() => {
        const fetchData = async () => {
            const res = await fetch(url);
            const dataArray = await res.json;
            setData(dataArray[0]);
        }

        fetchData();
    });

    return data;
}

export default useFetch();
```

## #`useReducer`:
- It lets us build reducer functions and leverage them as state management inside our components the same way `useState` does.
    - Except, it follows the flow of firing actions and then those action changing a reducer object. Like Redux, but localized to a component.

```js
const INITIAL_STATE = {
    user: null,
    searchQuery: 'Bert'
}

const reducer = (state, action) => {
    switch (action.type) {
        case 'SET_USER':
            return {
                ...state,
                user: action.payload
            }
        case 'SET_SEARCH_QUERY':
            return {
                ...state,
                searchQuery: action.payload
            }
        default:
            return state;
    }
}

const setUser = user => ({
    type: 'SET_USER',
    payload: user
});

const setQuery = queryString => ({
    type: 'SET_SEARCH_QUERY',
    payload: queryString
});

/*
.
.
.
*/

const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
const { user, searchQuery } = state;

dispatch(setUser(USER_DATA));
dispatch(setQuery(SEARCH_QUERY));
```