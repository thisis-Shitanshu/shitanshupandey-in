---
layout: post
title: "Redux"
categories: Redux
published: true
---

Notes on Redux

# #Introduction
- Redux allows React State to be more scalable.
    - Avoid use of drill-prop among nested React Component.
- Redux uses an architectural pattern called flux pattern.
    1. Action
    1. Dispatcher
    1. Store
    1. View

## #Why?
- Good for managing large state.
- Useful for sharing data between components.
- Predictable state management using the 3 principles.
    1. Single source of truth.
    1. State is read only.
    1. Changes using pure functions.

# #Redux Flow:
1. Actions
    - Middleware: Get action before they reach the Root Reducer.
    - E.g.: Redux logger
1. Root Reducer (pure function (action): state)
1. Store
1. DOM Changes

# #Reducer
- A function that gets state and playload as arrgument and returns state object.

```js
const userReducer = (currentState, action) => {
    switch(action.type) {
        case 'SET_CURRENT_USER':
            return {
                ...state,
                currentUser: action.payload
            };
        default:
            return state;
    }
};
```

# #Implementing Redux
- `yarn add redux redux-logger react-redux`
- Add `Provide` from `react-router` to the root of the app.
- Create Root reducer.
    - Create sub-reducer for specific accounts.
    - Combine them in root reducer and export combined state object.
- Create a store using Root reducer.
- Pass store in provider.

# #Memoization:
- Selectors are new value generated for the application from the current state of the application.
- Memoization is caching of selectors value.
- Which is achieved using `reselect` library.
    - It only passes value to react component if the value of selector has changed.
    - It makes the selector resuable and increase efficiency of code.

- Two types of selectors you can write with reselect:
    - Input Selector
    - Output Selector
        - Uses Input Selector

# #Redux-persist
- Persisting data on local storage.
- Redydrating persisted data on application restart.

- Store.js

```js
import { createStore, applyMiddleware } from 'redux';
import { persistStore } from 'redux-persist';
import logger from 'redux-logger';

import rootReducer from './root-reducer';

const middlewares = [logger];

const store = createStore(rootReducer, applyMiddleware(...middlewares));

const persistor = persistStore(store);

export { store , persistor };
```

- Reducer.js

```js
import { combineReducers } from 'redux';
import { persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

import userReducer from './user/user.reducer';
import cartReducer from './cart/cart.reducer';

const persistConfig = {
    key: 'root',
    storage,
    whitelist: [
        'cart'
    ]
};

const rootReducer = combineReducers({
    user: userReducer,
    cart: cartReducer
});

export default persistReducer(
    persistConfig, 
    rootReducer
);
```

- Wrapping the parent component:

```js
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';

import './index.css';
import App from './App';

import { store, persistor } from './redux/store';

ReactDOM.render(
    <Provider store={store}>
        <BrowserRouter>
            <PersistGate persistor={persistor}>
                <App />
            </PersistGate>
        </BrowserRouter>
    </Provider>, 
    document.getElementById('root')
);
```

## #Redux Thunk
- Library that handles asyncronous event handling and fire multiple actions.
- Action creator that returns a function that gets the dispatch.
    - Instead of creating an action that returns an action, Redux Thunk helps create a function that returns a function that gets dispatch init.
- If redux-thunk middleware is enabled, anytime you attempt to dispatch a function instead of an object, the middleware will call that function with dispatch method itself as the first argument.
- Redux-Thunk middleware only care about action function not action object.
    - It then passes dispatch to the function.

```js
export const fetchCollectionsStartAsync = () => {
  return dispatch => {
    const collectionRef = firestore.collection('collections');
    // D1: Dispatch another action to change redux state.
    dispatch(fetchCollectionsStart());

    collectionRef.get().then(snapshot => {
      const collectionsMap = convertCollectionsSnapshotToMap(snapshot);
      // D2
      dispatch(fetchCollectionsSuccess(collectionsMap));
    }).catch(error => dispatch(fetchCollectionsFailure(error.message)));
  }
};
```

# #Redux Saga
- Handling Side Effects (Async API Calls).
- Alternative to thunk.
- Function that conditionally run.
    - The condition that it depends on is based on whether a specific action is coming in to the Saga middleware.
    - When they do they can trigger other actions. Which go back into middlewares and continue with reducers.

- `$ yarn add redux-saga`

- After adding redux-saga to store middleware

```js
import { takeEvery, call, put } from 'redux-saga/effects';

import ShopActionTypes from './shop.types';

import { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils';

import {
    fetchCollectionsSuccess,
    fetchCollectionsFailure
} from './shop.actions';

export function* fetchCollectionsAsync() {
    yield console.log('I am fired');

    try {
        const collectionRef = firestore.collection('collections');

        const snapshot = yield collectionRef.get();
        const collectionsMap = yield call(convertCollectionsSnapshotToMap, snapshot);

        yield put(fetchCollectionsSuccess(collectionsMap));
    } catch (error) {
        yield put(fetchCollectionsFailure(error.message));
    }
}

export function* fetchCollectionsStart() {
    yield takeEvery(
        ShopActionTypes.FETCH_COLLECTIONS_START, 
        fetchCollectionsAsync    
    )
}
```

## #Listner Effects:
1. `take`:
    - No arguments passed.
    - Only listen to action.
    - Returns promise which is the action payload.
    - Basic Generator function, i.e., We can't restart the saga until it's completed, done is true.
1. `takeEvery`:
    - It restarts, respawn new task, the generator we pass to it, on repeatative same action call and listen to action.
    - Each sub-saga is spawn concurrently.
    - Building `take` to act like `takeEvery`
        - Force true to regenerate the task.
    ```js
    export function* incrementSaga() {
        while(true) {
            yield take('INCREMENT');
            yield console.log('I am incremented');
        }
    }
    ```
1. `takeLatest`:
    - Resolves each yield before it is called.
    - But Redux-saga cancels every previous saga spawn and issue the call one time, the latest one.
1. `delay`: Block the execution of code for ceratin time.
1. `put`: Creating actions from saga/ dispatch. Put everything back to redux flow.
    - `put({ type: 'INCREMENT_FROM_SAGA' });`
1. `all`:
    - Takes arrays of saga and run them concurrently.
1. `call`:
    - It is the effect inside the generator function the invokes another method.